-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Low-level networking interface
--   
--   This package provides a low-level networking interface.
--   
--   In network-2.6 the <tt>Network.URI</tt> module was split off into its
--   own package, network-uri-2.6. If you're using the <tt>Network.URI</tt>
--   module you can automatically get it from the right package by adding
--   this to your .cabal file:
--   
--   <pre>
--   flag network-uri
--     description: Get Network.URI from the network-uri package
--     default: True
--   
--   library
--     -- ...
--     if flag(network-uri)
--       build-depends: network-uri &gt;= 2.6, network &gt;= 2.6
--     else
--       build-depends: network-uri &lt; 2.6, network &lt; 2.6
--   </pre>
--   
--   That is, get the module from either network &lt; 2.6 or from
--   network-uri &gt;= 2.6.
@package network
@version 2.6.3.1


-- | A module containing semi-public <a>Socket</a> internals. Modules which
--   extend the <a>Socket</a> module will need to use this module while
--   ideally most users will be able to make do with the public interface.
module Network.Socket.Internal

-- | The raw network byte order number is read using host byte order.
--   Therefore on little-endian architectures the byte order is swapped.
--   For example <tt>127.0.0.1</tt> is represented as <tt>0x0100007f</tt>
--   on little-endian hosts and as <tt>0x7f000001</tt> on big-endian hosts.
--   
--   For direct manipulation prefer <a>hostAddressToTuple</a> and
--   <a>tupleToHostAddress</a>.
type HostAddress = Word32

-- | Independent of endianness. For example <tt>::1</tt> is stored as
--   <tt>(0, 0, 0, 1)</tt>.
--   
--   For direct manipulation prefer <a>hostAddress6ToTuple</a> and
--   <a>tupleToHostAddress6</a>.
type HostAddress6 = (Word32, Word32, Word32, Word32)
type FlowInfo = Word32
type ScopeID = Word32

-- | Use the <tt>Num</tt> instance (i.e. use a literal) to create a
--   <tt>PortNumber</tt> value with the correct network-byte-ordering. You
--   should not use the PortNum constructor. It will be removed in the next
--   release.
--   
--   <pre>
--   &gt;&gt;&gt; 1 :: PortNumber
--   1
--   
--   &gt;&gt;&gt; read "1" :: PortNumber
--   1
--   </pre>
newtype PortNumber

-- | <i>Deprecated: Do not use the PortNum constructor. Use the Num
--   instance. PortNum will be removed in the next release.</i>
PortNum :: Word16 -> PortNumber

-- | The existence of a constructor does not necessarily imply that that
--   socket address type is supported on your system: see
--   <a>isSupportedSockAddr</a>.
data SockAddr
SockAddrInet :: PortNumber -> HostAddress -> SockAddr
SockAddrInet6 :: PortNumber -> FlowInfo -> HostAddress6 -> ScopeID -> SockAddr
SockAddrUnix :: String -> SockAddr
SockAddrCan :: Int32 -> SockAddr

-- | Read a <a>SockAddr</a> from the given memory location.
peekSockAddr :: Ptr SockAddr -> IO SockAddr

-- | Write the given <a>SockAddr</a> to the given memory location.
pokeSockAddr :: Ptr a -> SockAddr -> IO ()

-- | Computes the storage requirements (in bytes) of the given
--   <a>SockAddr</a>. This function differs from <a>sizeOf</a> in that the
--   value of the argument <i>is</i> used.
sizeOfSockAddr :: SockAddr -> Int

-- | Computes the storage requirements (in bytes) required for a
--   <a>SockAddr</a> with the given <a>Family</a>.
sizeOfSockAddrByFamily :: Family -> Int

-- | Use a <a>SockAddr</a> with a function requiring a pointer to a
--   <a>SockAddr</a> and the length of that <a>SockAddr</a>.
withSockAddr :: SockAddr -> (Ptr SockAddr -> Int -> IO a) -> IO a

-- | Create a new <a>SockAddr</a> for use with a function requiring a
--   pointer to a <a>SockAddr</a> and the length of that <a>SockAddr</a>.
withNewSockAddr :: Family -> (Ptr SockAddr -> Int -> IO a) -> IO a

-- | Address families.
--   
--   A constructor being present here does not mean it is supported by the
--   operating system: see <a>isSupportedFamily</a>.
data Family
AF_UNSPEC :: Family
AF_UNIX :: Family
AF_INET :: Family
AF_INET6 :: Family
AF_IMPLINK :: Family
AF_PUP :: Family
AF_CHAOS :: Family
AF_NS :: Family
AF_NBS :: Family
AF_ECMA :: Family
AF_DATAKIT :: Family
AF_CCITT :: Family
AF_SNA :: Family
AF_DECnet :: Family
AF_DLI :: Family
AF_LAT :: Family
AF_HYLINK :: Family
AF_APPLETALK :: Family
AF_ROUTE :: Family
AF_NETBIOS :: Family
AF_NIT :: Family
AF_802 :: Family
AF_ISO :: Family
AF_OSI :: Family
AF_NETMAN :: Family
AF_X25 :: Family
AF_AX25 :: Family
AF_OSINET :: Family
AF_GOSSIP :: Family
AF_IPX :: Family
Pseudo_AF_XTP :: Family
AF_CTF :: Family
AF_WAN :: Family
AF_SDL :: Family
AF_NETWARE :: Family
AF_NDD :: Family
AF_INTF :: Family
AF_COIP :: Family
AF_CNT :: Family
Pseudo_AF_RTIP :: Family
Pseudo_AF_PIP :: Family
AF_SIP :: Family
AF_ISDN :: Family
Pseudo_AF_KEY :: Family
AF_NATM :: Family
AF_ARP :: Family
Pseudo_AF_HDRCMPLT :: Family
AF_ENCAP :: Family
AF_LINK :: Family
AF_RAW :: Family
AF_RIF :: Family
AF_NETROM :: Family
AF_BRIDGE :: Family
AF_ATMPVC :: Family
AF_ROSE :: Family
AF_NETBEUI :: Family
AF_SECURITY :: Family
AF_PACKET :: Family
AF_ASH :: Family
AF_ECONET :: Family
AF_ATMSVC :: Family
AF_IRDA :: Family
AF_PPPOX :: Family
AF_WANPIPE :: Family
AF_BLUETOOTH :: Family
AF_CAN :: Family

-- | Throw an <a>IOError</a> corresponding to the current socket error.
throwSocketError :: String -> IO a

-- | Like <a>throwSocketError</a>, but the error code is supplied as an
--   argument.
--   
--   On Windows, do not use errno. Use a system error code instead.
throwSocketErrorCode :: String -> CInt -> IO a

-- | Throw an <a>IOError</a> corresponding to the current socket error if
--   the IO action returns a result of <tt>-1</tt>. Discards the result of
--   the IO action after error handling.
throwSocketErrorIfMinus1_ :: (Eq a, Num a) => String -> IO a -> IO ()

-- | Throw an <a>IOError</a> corresponding to the current socket error if
--   the IO action returns a result of <tt>-1</tt>, but retries in case of
--   an interrupted operation.
throwSocketErrorIfMinus1Retry :: (Eq a, Num a) => String -> IO a -> IO a

-- | Throw an <a>IOError</a> corresponding to the current socket error if
--   the IO action returns a result of <tt>-1</tt>, but retries in case of
--   an interrupted operation. Discards the result of the IO action after
--   error handling.
throwSocketErrorIfMinus1Retry_ :: (Eq a, Num a) => String -> IO a -> IO ()

-- | Throw an <a>IOError</a> corresponding to the current socket error if
--   the IO action returns a result of <tt>-1</tt>, but retries in case of
--   an interrupted operation. Checks for operations that would block and
--   executes an alternative action before retrying in that case.
throwSocketErrorIfMinus1RetryMayBlock :: (Eq a, Num a) => String -> IO b -> IO a -> IO a

-- | Like <a>throwSocketErrorIfMinus1Retry</a>, but if the action fails
--   with <tt>EWOULDBLOCK</tt> or similar, wait for the socket to be
--   read-ready, and try again.
throwSocketErrorWaitRead :: (Eq a, Num a) => Socket -> String -> IO a -> IO a

-- | Like <a>throwSocketErrorIfMinus1Retry</a>, but if the action fails
--   with <tt>EWOULDBLOCK</tt> or similar, wait for the socket to be
--   write-ready, and try again.
throwSocketErrorWaitWrite :: (Eq a, Num a) => Socket -> String -> IO a -> IO a

-- | With older versions of the <tt>network</tt> library on Windows
--   operating systems, the networking subsystem must be initialised using
--   <a>withSocketsDo</a> before any networking operations can be used. eg.
--   
--   <pre>
--   main = withSocketsDo $ do {...}
--   </pre>
--   
--   It is fine to nest calls to <a>withSocketsDo</a>, and to perform
--   networking operations after <a>withSocketsDo</a> has returned.
--   
--   In newer versions of the <tt>network</tt> library it is only necessary
--   to call <a>withSocketsDo</a> if you are calling the <a>MkSocket</a>
--   constructor directly. However, for compatibility with older versions
--   on Windows, it is good practice to always call <a>withSocketsDo</a>
--   (it's very cheap).
withSocketsDo :: IO a -> IO a

-- | Zero a structure.
zeroMemory :: Ptr a -> CSize -> IO ()


-- | The <a>Network.Socket</a> module is for when you want full control
--   over sockets. Essentially the entire C socket API is exposed through
--   this module; in general the operations follow the behaviour of the C
--   functions of the same name (consult your favourite Unix networking
--   book).
--   
--   A higher level interface to networking operations is provided through
--   the module <a>Network</a>.
module Network.Socket

-- | Represents a socket. The fields are, respectively:
--   
--   <ul>
--   <li>File descriptor</li>
--   <li>Socket family</li>
--   <li>Socket type</li>
--   <li>Protocol number</li>
--   <li>Status flag</li>
--   </ul>
--   
--   If you are calling the <a>MkSocket</a> constructor directly you should
--   ensure you have called <a>withSocketsDo</a>.
data Socket
MkSocket :: CInt -> Family -> SocketType -> ProtocolNumber -> (MVar SocketStatus) -> Socket

-- | Address families.
--   
--   A constructor being present here does not mean it is supported by the
--   operating system: see <a>isSupportedFamily</a>.
data Family
AF_UNSPEC :: Family
AF_UNIX :: Family
AF_INET :: Family
AF_INET6 :: Family
AF_IMPLINK :: Family
AF_PUP :: Family
AF_CHAOS :: Family
AF_NS :: Family
AF_NBS :: Family
AF_ECMA :: Family
AF_DATAKIT :: Family
AF_CCITT :: Family
AF_SNA :: Family
AF_DECnet :: Family
AF_DLI :: Family
AF_LAT :: Family
AF_HYLINK :: Family
AF_APPLETALK :: Family
AF_ROUTE :: Family
AF_NETBIOS :: Family
AF_NIT :: Family
AF_802 :: Family
AF_ISO :: Family
AF_OSI :: Family
AF_NETMAN :: Family
AF_X25 :: Family
AF_AX25 :: Family
AF_OSINET :: Family
AF_GOSSIP :: Family
AF_IPX :: Family
Pseudo_AF_XTP :: Family
AF_CTF :: Family
AF_WAN :: Family
AF_SDL :: Family
AF_NETWARE :: Family
AF_NDD :: Family
AF_INTF :: Family
AF_COIP :: Family
AF_CNT :: Family
Pseudo_AF_RTIP :: Family
Pseudo_AF_PIP :: Family
AF_SIP :: Family
AF_ISDN :: Family
Pseudo_AF_KEY :: Family
AF_NATM :: Family
AF_ARP :: Family
Pseudo_AF_HDRCMPLT :: Family
AF_ENCAP :: Family
AF_LINK :: Family
AF_RAW :: Family
AF_RIF :: Family
AF_NETROM :: Family
AF_BRIDGE :: Family
AF_ATMPVC :: Family
AF_ROSE :: Family
AF_NETBEUI :: Family
AF_SECURITY :: Family
AF_PACKET :: Family
AF_ASH :: Family
AF_ECONET :: Family
AF_ATMSVC :: Family
AF_IRDA :: Family
AF_PPPOX :: Family
AF_WANPIPE :: Family
AF_BLUETOOTH :: Family
AF_CAN :: Family

-- | Does the AF_ constant corresponding to the given family exist on this
--   system?
isSupportedFamily :: Family -> Bool

-- | Socket Types.
--   
--   The existence of a constructor does not necessarily imply that that
--   socket type is supported on your system: see
--   <a>isSupportedSocketType</a>.
data SocketType

-- | 0, used in getAddrInfo hints, for example
NoSocketType :: SocketType

-- | SOCK_STREAM
Stream :: SocketType

-- | SOCK_DGRAM
Datagram :: SocketType

-- | SOCK_RAW
Raw :: SocketType

-- | SOCK_RDM
RDM :: SocketType

-- | SOCK_SEQPACKET
SeqPacket :: SocketType

-- | Does the SOCK_ constant corresponding to the given SocketType exist on
--   this system?
isSupportedSocketType :: SocketType -> Bool

-- | The existence of a constructor does not necessarily imply that that
--   socket address type is supported on your system: see
--   <a>isSupportedSockAddr</a>.
data SockAddr
SockAddrInet :: PortNumber -> HostAddress -> SockAddr
SockAddrInet6 :: PortNumber -> FlowInfo -> HostAddress6 -> ScopeID -> SockAddr
SockAddrUnix :: String -> SockAddr
SockAddrCan :: Int32 -> SockAddr

-- | Is the socket address type supported on this system?
isSupportedSockAddr :: SockAddr -> Bool

-- | The status of the socket as <i>determined by this library</i>, not
--   necessarily reflecting the state of the connection itself.
--   
--   For example, the <a>Closed</a> status is applied when the
--   <tt>close</tt> function is called.
data SocketStatus

-- | Newly created, unconnected socket
NotConnected :: SocketStatus

-- | Bound, via <tt>bind</tt>
Bound :: SocketStatus

-- | Listening, via <tt>listen</tt>
Listening :: SocketStatus

-- | Connected or accepted, via <tt>connect</tt> or <tt>accept</tt>
Connected :: SocketStatus

-- | Is now a <tt>Handle</tt> (via <tt>socketToHandle</tt>), don't touch
ConvertedToHandle :: SocketStatus

-- | Closed was closed by <tt>close</tt>
Closed :: SocketStatus

-- | The raw network byte order number is read using host byte order.
--   Therefore on little-endian architectures the byte order is swapped.
--   For example <tt>127.0.0.1</tt> is represented as <tt>0x0100007f</tt>
--   on little-endian hosts and as <tt>0x7f000001</tt> on big-endian hosts.
--   
--   For direct manipulation prefer <a>hostAddressToTuple</a> and
--   <a>tupleToHostAddress</a>.
type HostAddress = Word32

-- | Converts <a>HostAddress</a> to representation-independent IPv4
--   quadruple. For example for <tt>127.0.0.1</tt> the function will return
--   <tt>(0x7f, 0, 0, 1)</tt> regardless of host endianness.
hostAddressToTuple :: HostAddress -> (Word8, Word8, Word8, Word8)

-- | Converts IPv4 quadruple to <a>HostAddress</a>.
tupleToHostAddress :: (Word8, Word8, Word8, Word8) -> HostAddress

-- | Independent of endianness. For example <tt>::1</tt> is stored as
--   <tt>(0, 0, 0, 1)</tt>.
--   
--   For direct manipulation prefer <a>hostAddress6ToTuple</a> and
--   <a>tupleToHostAddress6</a>.
type HostAddress6 = (Word32, Word32, Word32, Word32)
hostAddress6ToTuple :: HostAddress6 -> (Word16, Word16, Word16, Word16, Word16, Word16, Word16, Word16)
tupleToHostAddress6 :: (Word16, Word16, Word16, Word16, Word16, Word16, Word16, Word16) -> HostAddress6
type FlowInfo = Word32
type ScopeID = Word32

-- | Converts the from host byte order to network byte order.
htonl :: Word32 -> Word32

-- | Converts the from network byte order to host byte order.
ntohl :: Word32 -> Word32
data ShutdownCmd
ShutdownReceive :: ShutdownCmd
ShutdownSend :: ShutdownCmd
ShutdownBoth :: ShutdownCmd
type ProtocolNumber = CInt

-- | This is the default protocol for a given service.
defaultProtocol :: ProtocolNumber

-- | Use the <tt>Num</tt> instance (i.e. use a literal) to create a
--   <tt>PortNumber</tt> value with the correct network-byte-ordering. You
--   should not use the PortNum constructor. It will be removed in the next
--   release.
--   
--   <pre>
--   &gt;&gt;&gt; 1 :: PortNumber
--   1
--   
--   &gt;&gt;&gt; read "1" :: PortNumber
--   1
--   </pre>
newtype PortNumber

-- | <i>Deprecated: Do not use the PortNum constructor. Use the Num
--   instance. PortNum will be removed in the next release.</i>
PortNum :: Word16 -> PortNumber

-- | Either a host name e.g., <tt>"haskell.org"</tt> or a numeric host
--   address string consisting of a dotted decimal IPv4 address or an IPv6
--   address e.g., <tt>"192.168.0.1"</tt>.
type HostName = String
type ServiceName = String
data AddrInfo
AddrInfo :: [AddrInfoFlag] -> Family -> SocketType -> ProtocolNumber -> SockAddr -> Maybe String -> AddrInfo
[addrFlags] :: AddrInfo -> [AddrInfoFlag]
[addrFamily] :: AddrInfo -> Family
[addrSocketType] :: AddrInfo -> SocketType
[addrProtocol] :: AddrInfo -> ProtocolNumber
[addrAddress] :: AddrInfo -> SockAddr
[addrCanonName] :: AddrInfo -> Maybe String

-- | Flags that control the querying behaviour of <a>getAddrInfo</a>. For
--   more information, see
--   <a>https://tools.ietf.org/html/rfc3493#page-25</a>
data AddrInfoFlag

-- | The list of returned <a>AddrInfo</a> values will only contain IPv4
--   addresses if the local system has at least one IPv4 interface
--   configured, and likewise for IPv6. (Only some platforms support this.)
AI_ADDRCONFIG :: AddrInfoFlag

-- | If <a>AI_ALL</a> is specified, return all matching IPv6 and IPv4
--   addresses. Otherwise, this flag has no effect. (Only some platforms
--   support this.)
AI_ALL :: AddrInfoFlag

-- | The <a>addrCanonName</a> field of the first returned <a>AddrInfo</a>
--   will contain the "canonical name" of the host.
AI_CANONNAME :: AddrInfoFlag

-- | The <a>HostName</a> argument <i>must</i> be a numeric address in
--   string form, and network name lookups will not be attempted.
AI_NUMERICHOST :: AddrInfoFlag

-- | The <a>ServiceName</a> argument <i>must</i> be a port number in string
--   form, and service name lookups will not be attempted. (Only some
--   platforms support this.)
AI_NUMERICSERV :: AddrInfoFlag

-- | If no <a>HostName</a> value is provided, the network address in each
--   <a>SockAddr</a> will be left as a "wild card", i.e. as either
--   <a>iNADDR_ANY</a> or <a>iN6ADDR_ANY</a>. This is useful for server
--   applications that will accept connections from any client.
AI_PASSIVE :: AddrInfoFlag

-- | If an IPv6 lookup is performed, and no IPv6 addresses are found,
--   IPv6-mapped IPv4 addresses will be returned. (Only some platforms
--   support this.)
AI_V4MAPPED :: AddrInfoFlag

-- | Indicate whether the given <a>AddrInfoFlag</a> will have any effect on
--   this system.
addrInfoFlagImplemented :: AddrInfoFlag -> Bool

-- | Default hints for address lookup with <a>getAddrInfo</a>. The values
--   of the <a>addrAddress</a> and <a>addrCanonName</a> fields are
--   <a>undefined</a>, and are never inspected by <a>getAddrInfo</a>.
--   
--   <pre>
--   &gt;&gt;&gt; addrFlags defaultHints
--   []
--   
--   &gt;&gt;&gt; addrFamily defaultHints
--   AF_UNSPEC
--   
--   &gt;&gt;&gt; addrSocketType defaultHints
--   NoSocketType
--   
--   &gt;&gt;&gt; addrProtocol defaultHints
--   0
--   </pre>
defaultHints :: AddrInfo

-- | Resolve a host or service name to one or more addresses. The
--   <a>AddrInfo</a> values that this function returns contain
--   <a>SockAddr</a> values that you can pass directly to <a>connect</a> or
--   <a>bind</a>.
--   
--   This function is protocol independent. It can return both IPv4 and
--   IPv6 address information.
--   
--   The <a>AddrInfo</a> argument specifies the preferred query behaviour,
--   socket options, or protocol. You can override these conveniently using
--   Haskell's record update syntax on <a>defaultHints</a>, for example as
--   follows:
--   
--   <pre>
--   &gt;&gt;&gt; let hints = defaultHints { addrFlags = [AI_NUMERICHOST], addrSocketType = Stream }
--   </pre>
--   
--   You must provide a <a>Just</a> value for at least one of the
--   <a>HostName</a> or <a>ServiceName</a> arguments. <a>HostName</a> can
--   be either a numeric network address (dotted quad for IPv4,
--   colon-separated hex for IPv6) or a hostname. In the latter case, its
--   addresses will be looked up unless <a>AI_NUMERICHOST</a> is specified
--   as a hint. If you do not provide a <a>HostName</a> value <i>and</i> do
--   not set <a>AI_PASSIVE</a> as a hint, network addresses in the result
--   will contain the address of the loopback interface.
--   
--   If the query fails, this function throws an IO exception instead of
--   returning an empty list. Otherwise, it returns a non-empty list of
--   <a>AddrInfo</a> values.
--   
--   There are several reasons why a query might result in several values.
--   For example, the queried-for host could be multihomed, or the service
--   might be available via several protocols.
--   
--   Note: the order of arguments is slightly different to that defined for
--   <tt>getaddrinfo</tt> in RFC 2553. The <a>AddrInfo</a> parameter comes
--   first to make partial application easier.
--   
--   <pre>
--   &gt;&gt;&gt; addr:_ &lt;- getAddrInfo (Just hints) (Just "127.0.0.1") (Just "http")
--   
--   &gt;&gt;&gt; addrAddress addr
--   127.0.0.1:80
--   </pre>
getAddrInfo :: Maybe AddrInfo -> Maybe HostName -> Maybe ServiceName -> IO [AddrInfo]

-- | Flags that control the querying behaviour of <a>getNameInfo</a>. For
--   more information, see
--   <a>https://tools.ietf.org/html/rfc3493#page-30</a>
data NameInfoFlag

-- | Resolve a datagram-based service name. This is required only for the
--   few protocols that have different port numbers for their
--   datagram-based versions than for their stream-based versions.
NI_DGRAM :: NameInfoFlag

-- | If the hostname cannot be looked up, an IO error is thrown.
NI_NAMEREQD :: NameInfoFlag

-- | If a host is local, return only the hostname part of the FQDN.
NI_NOFQDN :: NameInfoFlag

-- | The name of the host is not looked up. Instead, a numeric
--   representation of the host's address is returned. For an IPv4 address,
--   this will be a dotted-quad string. For IPv6, it will be
--   colon-separated hexadecimal.
NI_NUMERICHOST :: NameInfoFlag

-- | The name of the service is not looked up. Instead, a numeric
--   representation of the service is returned.
NI_NUMERICSERV :: NameInfoFlag

-- | Resolve an address to a host or service name. This function is
--   protocol independent. The list of <a>NameInfoFlag</a> values controls
--   query behaviour.
--   
--   If a host or service's name cannot be looked up, then the numeric form
--   of the address or service will be returned.
--   
--   If the query fails, this function throws an IO exception.
--   
--   Example: <tt> (hostName, _) &lt;- getNameInfo [] True False myAddress
--   </tt>
getNameInfo :: [NameInfoFlag] -> Bool -> Bool -> SockAddr -> IO (Maybe HostName, Maybe ServiceName)

-- | Create a new socket using the given address family, socket type and
--   protocol number. The address family is usually <a>AF_INET</a>,
--   <a>AF_INET6</a>, or <a>AF_UNIX</a>. The socket type is usually
--   <a>Stream</a> or <a>Datagram</a>. The protocol number is usually
--   <a>defaultProtocol</a>. If <a>AF_INET6</a> is used and the socket type
--   is <a>Stream</a> or <a>Datagram</a>, the <a>IPv6Only</a> socket option
--   is set to 0 so that both IPv4 and IPv6 can be handled with one socket.
--   
--   <pre>
--   &gt;&gt;&gt; let hints = defaultHints { addrFlags = [AI_NUMERICHOST, AI_NUMERICSERV], addrSocketType = Stream }
--   
--   &gt;&gt;&gt; addr:_ &lt;- getAddrInfo (Just hints) (Just "127.0.0.1") (Just "5000")
--   
--   &gt;&gt;&gt; sock@(MkSocket _ fam stype _ _) &lt;- socket (addrFamily addr) (addrSocketType addr) (addrProtocol addr)
--   
--   &gt;&gt;&gt; fam
--   AF_INET
--   
--   &gt;&gt;&gt; stype
--   Stream
--   
--   &gt;&gt;&gt; bind sock (addrAddress addr)
--   
--   &gt;&gt;&gt; getSocketName sock
--   127.0.0.1:5000
--   </pre>
socket :: Family -> SocketType -> ProtocolNumber -> IO Socket

-- | Build a pair of connected socket objects using the given address
--   family, socket type, and protocol number. Address family, socket type,
--   and protocol number are as for the <a>socket</a> function above.
--   Availability: Unix.
socketPair :: Family -> SocketType -> ProtocolNumber -> IO (Socket, Socket)

-- | Connect to a remote socket at address.
connect :: Socket -> SockAddr -> IO ()

-- | Bind the socket to an address. The socket must not already be bound.
--   The <a>Family</a> passed to <tt>bind</tt> must be the same as that
--   passed to <a>socket</a>. If the special port number <a>aNY_PORT</a> is
--   passed then the system assigns the next available use port.
bind :: Socket -> SockAddr -> IO ()

-- | Listen for connections made to the socket. The second argument
--   specifies the maximum number of queued connections and should be at
--   least 1; the maximum value is system-dependent (usually 5).
listen :: Socket -> Int -> IO ()

-- | Accept a connection. The socket must be bound to an address and
--   listening for connections. The return value is a pair <tt>(conn,
--   address)</tt> where <tt>conn</tt> is a new socket object usable to
--   send and receive data on the connection, and <tt>address</tt> is the
--   address bound to the socket on the other end of the connection.
accept :: Socket -> IO (Socket, SockAddr)
getPeerName :: Socket -> IO SockAddr
getSocketName :: Socket -> IO SockAddr

-- | Returns the processID, userID and groupID of the socket's peer.
--   
--   Only available on platforms that support SO_PEERCRED or GETPEEREID(3)
--   on domain sockets. GETPEEREID(3) returns userID and groupID. processID
--   is always 0.
getPeerCred :: Socket -> IO (CUInt, CUInt, CUInt)

-- | The getpeereid() function returns the effective user and group IDs of
--   the peer connected to a UNIX-domain socket
getPeerEid :: Socket -> IO (CUInt, CUInt)
socketPort :: Socket -> IO PortNumber

-- | Turns a Socket into an <a>Handle</a>. By default, the new handle is
--   unbuffered. Use <a>hSetBuffering</a> to change the buffering.
--   
--   Note that since a <a>Handle</a> is automatically closed by a finalizer
--   when it is no longer referenced, you should avoid doing any more
--   operations on the <a>Socket</a> after calling <a>socketToHandle</a>.
--   To close the <a>Socket</a> after <a>socketToHandle</a>, call
--   <a>hClose</a> on the <a>Handle</a>.
socketToHandle :: Socket -> IOMode -> IO Handle

-- | Send data to the socket. The socket must be connected to a remote
--   socket. Returns the number of bytes sent. Applications are responsible
--   for ensuring that all data has been sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.

-- | <i>Warning: Use send defined in <a>Network.Socket.ByteString</a></i>
send :: Socket -> String -> IO Int

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. Returns the number of
--   bytes sent. Applications are responsible for ensuring that all data
--   has been sent.
--   
--   NOTE: blocking on Windows unless you compile with -threaded (see GHC
--   ticket #1129)

-- | <i>Warning: Use sendTo defined in <a>Network.Socket.ByteString</a></i>
sendTo :: Socket -> String -> SockAddr -> IO Int

-- | Receive data from the socket. The socket must be in a connected state.
--   This function may return fewer bytes than specified. If the message is
--   longer than the specified length, it may be discarded depending on the
--   type of socket. This function may block until a message arrives.
--   
--   Considering hardware and network realities, the maximum number of
--   bytes to receive should be a small power of 2, e.g., 4096.
--   
--   For TCP sockets, a zero length return value means the peer has closed
--   its half side of the connection.
--   
--   Receiving data from closed socket may lead to undefined behaviour.

-- | <i>Warning: Use recv defined in <a>Network.Socket.ByteString</a></i>
recv :: Socket -> Int -> IO String

-- | Receive data from the socket. The socket need not be in a connected
--   state. Returns <tt>(bytes, nbytes, address)</tt> where <tt>bytes</tt>
--   is a <tt>String</tt> of length <tt>nbytes</tt> representing the data
--   received and <tt>address</tt> is a <a>SockAddr</a> representing the
--   address of the sending socket.
--   
--   NOTE: blocking on Windows unless you compile with -threaded (see GHC
--   ticket #1129)

-- | <i>Warning: Use recvFrom defined in
--   <a>Network.Socket.ByteString</a></i>
recvFrom :: Socket -> Int -> IO (String, Int, SockAddr)

-- | <i>Warning: Use recvLen defined in
--   <a>Network.Socket.ByteString</a></i>
recvLen :: Socket -> Int -> IO (String, Int)

-- | Send data to the socket. The socket must be connected to a remote
--   socket. Returns the number of bytes sent. Applications are responsible
--   for ensuring that all data has been sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.
sendBuf :: Socket -> Ptr Word8 -> Int -> IO Int

-- | Receive data from the socket. The socket must be in a connected state.
--   This function may return fewer bytes than specified. If the message is
--   longer than the specified length, it may be discarded depending on the
--   type of socket. This function may block until a message arrives.
--   
--   Considering hardware and network realities, the maximum number of
--   bytes to receive should be a small power of 2, e.g., 4096.
--   
--   For TCP sockets, a zero length return value means the peer has closed
--   its half side of the connection.
--   
--   Receiving data from closed socket may lead to undefined behaviour.
recvBuf :: Socket -> Ptr Word8 -> Int -> IO Int

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. Returns the number of
--   bytes sent. Applications are responsible for ensuring that all data
--   has been sent.
sendBufTo :: Socket -> Ptr a -> Int -> SockAddr -> IO Int

-- | Receive data from the socket, writing it into buffer instead of
--   creating a new string. The socket need not be in a connected state.
--   Returns <tt>(nbytes, address)</tt> where <tt>nbytes</tt> is the number
--   of bytes received and <tt>address</tt> is a <a>SockAddr</a>
--   representing the address of the sending socket.
--   
--   NOTE: blocking on Windows unless you compile with -threaded (see GHC
--   ticket #1129)
recvBufFrom :: Socket -> Ptr a -> Int -> IO (Int, SockAddr)
inet_addr :: String -> IO HostAddress
inet_ntoa :: HostAddress -> IO String

-- | Shut down one or both halves of the connection, depending on the
--   second argument to the function. If the second argument is
--   <a>ShutdownReceive</a>, further receives are disallowed. If it is
--   <a>ShutdownSend</a>, further sends are disallowed. If it is
--   <a>ShutdownBoth</a>, further sends and receives are disallowed.
shutdown :: Socket -> ShutdownCmd -> IO ()

-- | Close the socket. Sending data to or receiving data from closed socket
--   may lead to undefined behaviour.
close :: Socket -> IO ()

-- | Determines whether <a>close</a> has been used on the <a>Socket</a>.
--   This does <i>not</i> indicate any status about the socket beyond this.
--   If the socket has been closed remotely, this function can still return
--   <a>True</a>.
isConnected :: Socket -> IO Bool
isBound :: Socket -> IO Bool
isListening :: Socket -> IO Bool
isReadable :: Socket -> IO Bool
isWritable :: Socket -> IO Bool

-- | Socket options for use with <a>setSocketOption</a> and
--   <a>getSocketOption</a>.
--   
--   The existence of a constructor does not imply that the relevant option
--   is supported on your system: see <a>isSupportedSocketOption</a>
data SocketOption

-- | SO_DEBUG
Debug :: SocketOption

-- | SO_REUSEADDR
ReuseAddr :: SocketOption

-- | SO_TYPE
Type :: SocketOption

-- | SO_ERROR
SoError :: SocketOption

-- | SO_DONTROUTE
DontRoute :: SocketOption

-- | SO_BROADCAST
Broadcast :: SocketOption

-- | SO_SNDBUF
SendBuffer :: SocketOption

-- | SO_RCVBUF
RecvBuffer :: SocketOption

-- | SO_KEEPALIVE
KeepAlive :: SocketOption

-- | SO_OOBINLINE
OOBInline :: SocketOption

-- | IP_TTL
TimeToLive :: SocketOption

-- | TCP_MAXSEG
MaxSegment :: SocketOption

-- | TCP_NODELAY
NoDelay :: SocketOption

-- | TCP_CORK
Cork :: SocketOption

-- | SO_LINGER
Linger :: SocketOption

-- | SO_REUSEPORT
ReusePort :: SocketOption

-- | SO_RCVLOWAT
RecvLowWater :: SocketOption

-- | SO_SNDLOWAT
SendLowWater :: SocketOption

-- | SO_RCVTIMEO
RecvTimeOut :: SocketOption

-- | SO_SNDTIMEO
SendTimeOut :: SocketOption

-- | SO_USELOOPBACK
UseLoopBack :: SocketOption

-- | TCP_USER_TIMEOUT
UserTimeout :: SocketOption

-- | IPV6_V6ONLY
IPv6Only :: SocketOption
CustomSockOpt :: (CInt, CInt) -> SocketOption

-- | Does the <a>SocketOption</a> exist on this system?
isSupportedSocketOption :: SocketOption -> Bool

-- | Get a socket option that gives an Int value. There is currently no API
--   to get e.g. the timeval socket options
getSocketOption :: Socket -> SocketOption -> IO Int

-- | Set a socket option that expects an Int value. There is currently no
--   API to set e.g. the timeval socket options
setSocketOption :: Socket -> SocketOption -> Int -> IO ()
sendFd :: Socket -> CInt -> IO ()
recvFd :: Socket -> IO CInt
aNY_PORT :: PortNumber

-- | The IPv4 wild card address.
iNADDR_ANY :: HostAddress

-- | The IPv6 wild card address.
iN6ADDR_ANY :: HostAddress6
sOMAXCONN :: Int
sOL_SOCKET :: Int
sCM_RIGHTS :: Int

-- | This is the value of SOMAXCONN, typically 128. 128 is good enough for
--   normal network servers but is too small for high performance servers.
maxListenQueue :: Int

-- | With older versions of the <tt>network</tt> library on Windows
--   operating systems, the networking subsystem must be initialised using
--   <a>withSocketsDo</a> before any networking operations can be used. eg.
--   
--   <pre>
--   main = withSocketsDo $ do {...}
--   </pre>
--   
--   It is fine to nest calls to <a>withSocketsDo</a>, and to perform
--   networking operations after <a>withSocketsDo</a> has returned.
--   
--   In newer versions of the <tt>network</tt> library it is only necessary
--   to call <a>withSocketsDo</a> if you are calling the <a>MkSocket</a>
--   constructor directly. However, for compatibility with older versions
--   on Windows, it is good practice to always call <a>withSocketsDo</a>
--   (it's very cheap).
withSocketsDo :: IO a -> IO a
fdSocket :: Socket -> CInt
mkSocket :: CInt -> Family -> SocketType -> ProtocolNumber -> SocketStatus -> IO Socket

-- | Deprecated alias for <a>bind</a>.

-- | <i>Deprecated: use <a>bind</a></i>
bindSocket :: Socket -> SockAddr -> IO ()

-- | Deprecated alias for <a>close</a>.

-- | <i>Deprecated: use <a>close</a></i>
sClose :: Socket -> IO ()

-- | Deprecated alias for <a>isConnected</a>.

-- | <i>Deprecated: use <a>isConnected</a></i>
sIsConnected :: Socket -> IO Bool

-- | Deprecated alias for <a>isBound</a>.

-- | <i>Deprecated: use <a>isBound</a></i>
sIsBound :: Socket -> IO Bool

-- | Deprecated alias for <a>isListening</a>.

-- | <i>Deprecated: use <a>isListening</a></i>
sIsListening :: Socket -> IO Bool

-- | Deprecated alias for <a>isReadable</a>.

-- | <i>Deprecated: use <a>isReadable</a></i>
sIsReadable :: Socket -> IO Bool

-- | Deprecated alias for <a>isWritable</a>.

-- | <i>Deprecated: use <a>isWritable</a></i>
sIsWritable :: Socket -> IO Bool
packFamily :: Family -> CInt
unpackFamily :: CInt -> Family
packSocketType :: SocketType -> CInt
instance GHC.Show.Show Network.Socket.NameInfoFlag
instance GHC.Read.Read Network.Socket.NameInfoFlag
instance GHC.Classes.Eq Network.Socket.NameInfoFlag
instance GHC.Show.Show Network.Socket.AddrInfo
instance GHC.Classes.Eq Network.Socket.AddrInfo
instance GHC.Show.Show Network.Socket.AddrInfoFlag
instance GHC.Read.Read Network.Socket.AddrInfoFlag
instance GHC.Classes.Eq Network.Socket.AddrInfoFlag
instance GHC.Show.Show Network.Socket.SocketOption
instance GHC.Show.Show Network.Socket.Types.SockAddr
instance Foreign.Storable.Storable Network.Socket.AddrInfo


-- | This module provides access to the BSD <i>socket</i> interface. This
--   module is generally more efficient than the <a>String</a> based
--   network functions in <a>Socket</a>. For detailed documentation,
--   consult your favorite POSIX socket reference. All functions
--   communicate failures by converting the error number to <a>IOError</a>.
--   
--   This module is made to be imported with <a>Socket</a> like so:
--   
--   <pre>
--   import Network.Socket hiding (send, sendTo, recv, recvFrom)
--   import Network.Socket.ByteString
--   </pre>
module Network.Socket.ByteString

-- | Send data to the socket. The socket must be connected to a remote
--   socket. Returns the number of bytes sent. Applications are responsible
--   for ensuring that all data has been sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.
send :: Socket -> ByteString -> IO Int

-- | Send data to the socket. The socket must be connected to a remote
--   socket. Unlike <a>send</a>, this function continues to send data until
--   either all data has been sent or an error occurs. On error, an
--   exception is raised, and there is no way to determine how much data,
--   if any, was successfully sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.
sendAll :: Socket -> ByteString -> IO ()

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. Returns the number of
--   bytes sent. Applications are responsible for ensuring that all data
--   has been sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.
sendTo :: Socket -> ByteString -> SockAddr -> IO Int

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. Unlike <a>sendTo</a>,
--   this function continues to send data until either all data has been
--   sent or an error occurs. On error, an exception is raised, and there
--   is no way to determine how much data, if any, was successfully sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.
sendAllTo :: Socket -> ByteString -> SockAddr -> IO ()

-- | Send data to the socket. The socket must be in a connected state. The
--   data is sent as if the parts have been concatenated. This function
--   continues to send data until either all data has been sent or an error
--   occurs. On error, an exception is raised, and there is no way to
--   determine how much data, if any, was successfully sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.
sendMany :: Socket -> [ByteString] -> IO ()

-- | Send data to the socket. The recipient can be specified explicitly, so
--   the socket need not be in a connected state. The data is sent as if
--   the parts have been concatenated. This function continues to send data
--   until either all data has been sent or an error occurs. On error, an
--   exception is raised, and there is no way to determine how much data,
--   if any, was successfully sent.
--   
--   Sending data to closed socket may lead to undefined behaviour.
sendManyTo :: Socket -> [ByteString] -> SockAddr -> IO ()

-- | Receive data from the socket. The socket must be in a connected state.
--   This function may return fewer bytes than specified. If the message is
--   longer than the specified length, it may be discarded depending on the
--   type of socket. This function may block until a message arrives.
--   
--   Considering hardware and network realities, the maximum number of
--   bytes to receive should be a small power of 2, e.g., 4096.
--   
--   For TCP sockets, a zero length return value means the peer has closed
--   its half side of the connection.
--   
--   Receiving data from closed socket may lead to undefined behaviour.
recv :: Socket -> Int -> IO ByteString

-- | Receive data from the socket. The socket need not be in a connected
--   state. Returns <tt>(bytes, address)</tt> where <tt>bytes</tt> is a
--   <a>ByteString</a> representing the data received and <tt>address</tt>
--   is a <a>SockAddr</a> representing the address of the sending socket.
--   
--   Receiving data from closed socket may lead to undefined behaviour.
recvFrom :: Socket -> Int -> IO (ByteString, SockAddr)


-- | This module provides access to the BSD <i>socket</i> interface. This
--   module is generally more efficient than the <a>String</a> based
--   network functions in <a>Socket</a>. For detailed documentation,
--   consult your favorite POSIX socket reference. All functions
--   communicate failures by converting the error number to <a>IOError</a>.
--   
--   This module is made to be imported with <a>Socket</a> like so:
--   
--   <pre>
--   import Network.Socket hiding (send, sendTo, recv, recvFrom)
--   import Network.Socket.ByteString.Lazy
--   import Prelude hiding (getContents)
--   </pre>
module Network.Socket.ByteString.Lazy
send :: Socket -> ByteString -> IO Int64
sendAll :: Socket -> ByteString -> IO ()

-- | Receive data from the socket. The socket must be in a connected state.
--   Data is received on demand, in chunks; each chunk will be sized to
--   reflect the amount of data received by individual <a>recv</a> calls.
--   
--   All remaining data from the socket is consumed. When there is no more
--   data to be received, the receiving side of the socket is shut down. If
--   there is an error and an exception is thrown, the socket is not shut
--   down.
getContents :: Socket -> IO ByteString

-- | Receive data from the socket. The socket must be in a connected state.
--   This function may return fewer bytes than specified. If the received
--   data is longer than the specified length, it may be discarded
--   depending on the type of socket. This function may block until a
--   message arrives.
--   
--   If there is no more data to be received, returns an empty
--   <a>ByteString</a>.
--   
--   Receiving data from closed socket may lead to undefined behaviour.
recv :: Socket -> Int64 -> IO ByteString


-- | The <a>Network.BSD</a> module defines Haskell bindings to network
--   programming functionality provided by BSD Unix derivatives.
module Network.BSD

-- | Either a host name e.g., <tt>"haskell.org"</tt> or a numeric host
--   address string consisting of a dotted decimal IPv4 address or an IPv6
--   address e.g., <tt>"192.168.0.1"</tt>.
type HostName = String

-- | Calling getHostName returns the standard host name for the current
--   processor, as set at boot time.
getHostName :: IO HostName
data HostEntry
HostEntry :: HostName -> [HostName] -> Family -> [HostAddress] -> HostEntry
[hostName] :: HostEntry -> HostName
[hostAliases] :: HostEntry -> [HostName]
[hostFamily] :: HostEntry -> Family
[hostAddresses] :: HostEntry -> [HostAddress]

-- | Resolve a <a>HostName</a> to IPv4 address.
getHostByName :: HostName -> IO HostEntry

-- | Get a <a>HostEntry</a> corresponding to the given address and family.
--   Note that only IPv4 is currently supported.
getHostByAddr :: Family -> HostAddress -> IO HostEntry
hostAddress :: HostEntry -> HostAddress
getHostEntries :: Bool -> IO [HostEntry]
setHostEntry :: Bool -> IO ()
getHostEntry :: IO HostEntry
endHostEntry :: IO ()
data ServiceEntry
ServiceEntry :: ServiceName -> [ServiceName] -> PortNumber -> ProtocolName -> ServiceEntry
[serviceName] :: ServiceEntry -> ServiceName
[serviceAliases] :: ServiceEntry -> [ServiceName]
[servicePort] :: ServiceEntry -> PortNumber
[serviceProtocol] :: ServiceEntry -> ProtocolName
type ServiceName = String

-- | Get service by name.
getServiceByName :: ServiceName -> ProtocolName -> IO ServiceEntry

-- | Get the service given a <a>PortNumber</a> and <a>ProtocolName</a>.
getServiceByPort :: PortNumber -> ProtocolName -> IO ServiceEntry

-- | Get the <a>PortNumber</a> corresponding to the <a>ServiceName</a>.
getServicePortNumber :: ServiceName -> IO PortNumber
getServiceEntries :: Bool -> IO [ServiceEntry]
getServiceEntry :: IO ServiceEntry
setServiceEntry :: Bool -> IO ()
endServiceEntry :: IO ()
type ProtocolName = String
type ProtocolNumber = CInt
data ProtocolEntry
ProtocolEntry :: ProtocolName -> [ProtocolName] -> ProtocolNumber -> ProtocolEntry
[protoName] :: ProtocolEntry -> ProtocolName
[protoAliases] :: ProtocolEntry -> [ProtocolName]
[protoNumber] :: ProtocolEntry -> ProtocolNumber
getProtocolByName :: ProtocolName -> IO ProtocolEntry
getProtocolByNumber :: ProtocolNumber -> IO ProtocolEntry
getProtocolNumber :: ProtocolName -> IO ProtocolNumber

-- | This is the default protocol for a given service.
defaultProtocol :: ProtocolNumber
getProtocolEntries :: Bool -> IO [ProtocolEntry]
setProtocolEntry :: Bool -> IO ()
getProtocolEntry :: IO ProtocolEntry
endProtocolEntry :: IO ()

-- | Use the <tt>Num</tt> instance (i.e. use a literal) to create a
--   <tt>PortNumber</tt> value with the correct network-byte-ordering. You
--   should not use the PortNum constructor. It will be removed in the next
--   release.
--   
--   <pre>
--   &gt;&gt;&gt; 1 :: PortNumber
--   1
--   
--   &gt;&gt;&gt; read "1" :: PortNumber
--   1
--   </pre>
data PortNumber
type NetworkName = String
type NetworkAddr = CULong
data NetworkEntry
NetworkEntry :: NetworkName -> [NetworkName] -> Family -> NetworkAddr -> NetworkEntry
[networkName] :: NetworkEntry -> NetworkName
[networkAliases] :: NetworkEntry -> [NetworkName]
[networkFamily] :: NetworkEntry -> Family
[networkAddress] :: NetworkEntry -> NetworkAddr
getNetworkByName :: NetworkName -> IO NetworkEntry
getNetworkByAddr :: NetworkAddr -> Family -> IO NetworkEntry

-- | Get the list of network entries.
getNetworkEntries :: Bool -> IO [NetworkEntry]

-- | Open the network name database. The parameter specifies whether a
--   connection is maintained open between various networkEntry calls
setNetworkEntry :: Bool -> IO ()
getNetworkEntry :: IO NetworkEntry

-- | Close the connection to the network name database.
endNetworkEntry :: IO ()
ifNameToIndex :: String -> IO (Maybe Int)
instance GHC.Show.Show Network.BSD.NetworkEntry
instance GHC.Read.Read Network.BSD.NetworkEntry
instance GHC.Show.Show Network.BSD.HostEntry
instance GHC.Read.Read Network.BSD.HostEntry
instance GHC.Show.Show Network.BSD.ProtocolEntry
instance GHC.Read.Read Network.BSD.ProtocolEntry
instance GHC.Show.Show Network.BSD.ServiceEntry
instance Foreign.Storable.Storable Network.BSD.ServiceEntry
instance Foreign.Storable.Storable Network.BSD.ProtocolEntry
instance Foreign.Storable.Storable Network.BSD.HostEntry
instance Foreign.Storable.Storable Network.BSD.NetworkEntry


-- | This module is kept for backwards-compatibility. New users are
--   encouraged to use <a>Network.Socket</a> instead.
--   
--   <a>Network</a> was intended as a "higher-level" interface to
--   networking facilities, and only supports TCP.
module Network

-- | Represents a socket. The fields are, respectively:
--   
--   <ul>
--   <li>File descriptor</li>
--   <li>Socket family</li>
--   <li>Socket type</li>
--   <li>Protocol number</li>
--   <li>Status flag</li>
--   </ul>
--   
--   If you are calling the <a>MkSocket</a> constructor directly you should
--   ensure you have called <a>withSocketsDo</a>.
data Socket
data PortID
Service :: String -> PortID
PortNumber :: PortNumber -> PortID
UnixSocket :: String -> PortID

-- | Either a host name e.g., <tt>"haskell.org"</tt> or a numeric host
--   address string consisting of a dotted decimal IPv4 address or an IPv6
--   address e.g., <tt>"192.168.0.1"</tt>.
type HostName = String

-- | Use the <tt>Num</tt> instance (i.e. use a literal) to create a
--   <tt>PortNumber</tt> value with the correct network-byte-ordering. You
--   should not use the PortNum constructor. It will be removed in the next
--   release.
--   
--   <pre>
--   &gt;&gt;&gt; 1 :: PortNumber
--   1
--   
--   &gt;&gt;&gt; read "1" :: PortNumber
--   1
--   </pre>
data PortNumber

-- | With older versions of the <tt>network</tt> library on Windows
--   operating systems, the networking subsystem must be initialised using
--   <a>withSocketsDo</a> before any networking operations can be used. eg.
--   
--   <pre>
--   main = withSocketsDo $ do {...}
--   </pre>
--   
--   It is fine to nest calls to <a>withSocketsDo</a>, and to perform
--   networking operations after <a>withSocketsDo</a> has returned.
--   
--   In newer versions of the <tt>network</tt> library it is only necessary
--   to call <a>withSocketsDo</a> if you are calling the <a>MkSocket</a>
--   constructor directly. However, for compatibility with older versions
--   on Windows, it is good practice to always call <a>withSocketsDo</a>
--   (it's very cheap).
withSocketsDo :: IO a -> IO a

-- | Creates the server side socket which has been bound to the specified
--   port.
--   
--   <a>maxListenQueue</a> (typically 128) is specified to the listen
--   queue. This is good enough for normal network servers but is too small
--   for high performance servers.
--   
--   To avoid the "Address already in use" problems, the <a>ReuseAddr</a>
--   socket option is set on the listening socket.
--   
--   If available, the <a>IPv6Only</a> socket option is set to 0 so that
--   both IPv4 and IPv6 can be accepted with this socket.
--   
--   If you don't like the behavior above, please use the lower level
--   <a>listen</a> instead.
listenOn :: PortID -> IO Socket

-- | Accept a connection on a socket created by <a>listenOn</a>. Normal I/O
--   operations (see <a>System.IO</a>) can be used on the <a>Handle</a>
--   returned to communicate with the client. Notice that although you can
--   pass any Socket to Network.accept, only sockets of either AF_UNIX,
--   AF_INET, or AF_INET6 will work (this shouldn't be a problem, though).
--   When using AF_UNIX, HostName will be set to the path of the socket and
--   PortNumber to -1.
accept :: Socket -> IO (Handle, HostName, PortNumber)

-- | Close the socket. Sending data to or receiving data from closed socket
--   may lead to undefined behaviour.
sClose :: Socket -> IO ()

-- | Calling <a>connectTo</a> creates a client side socket which is
--   connected to the given host and port. The Protocol and socket type is
--   derived from the given port identifier. If a port number is given then
--   the result is always an internet family <a>Stream</a> socket.
connectTo :: HostName -> PortID -> IO Handle
sendTo :: HostName -> PortID -> String -> IO ()
recvFrom :: HostName -> PortID -> IO String

-- | Returns the <a>PortID</a> associated with a given socket.
socketPort :: Socket -> IO PortID
instance GHC.Classes.Eq Network.PortID
instance GHC.Show.Show Network.PortID
